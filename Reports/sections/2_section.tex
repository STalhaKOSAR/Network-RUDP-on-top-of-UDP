In the second part of this experiment we are asked to design our protocol on top of UDP, and make it reliable, apply multihoming and pipe-lining. At the end, our protocol should be topology and configuration free which implies that our protocol should be applicable on any network designed by anyone with any configurations.
\subsection{Routing Table}
In the second part of term project we are asked to resolve dependencies on router's scripts, i.e. we need to modify routing tables to achieve this. By doing so, there is no need to write scripts for routers. The router nodes only responsible for routing data to appropriate IPs. Briefly, we can say that routing table has similar idea with mapping in package delivery. While sending data from one node to another, sender node must know where to send the data firstly. If there are no links connecting directly sender and receiver nodes, data must be send via other nodes using route tables in the way to find proper way. A node sends an IP packet to proper gateway in network then router decide how to route correct destination and gateways use routing table to keep track of data. Basically, routing table is a database to keep track of data like having a map to decide which way to forward in the traffic. When we have created a slice in \href{https://portal.geni.net}{GENI} platform for term project part 2 and added updated resources given in first part. After that default interfaces' IPs are shown ($Fig. 4$)[See Appendix in Section \ref{appendix}]\\
Based on $Figure 4$, the default routing table in routers are shown in $Fig. 5$ [See Appendix in Section \ref{appendix}]\\
In $Fig.5$ routing table shows if incoming packet destination matches with the IP in Destination column, then direct it to it's corresponding Gateway value. For example, if incoming packet's IP is $10.10.3.0$ in broker node, direct it to $10.10.2.2$, same situation is valid for other nodes. At this point we need to modify the routing table to remove the dependency on router's script. By writing route commands in machine, we have done that (To see all exact commands please check README.md)

e.g. sudo route add -net [IP of node that packet is destinated] netmask [Netmask] gw [IP of node to be routed] dev [link]\\
\newpage
After making modifications, route table for router 1 does:\\
Incoming packets having IP $10.10.3.0$ will be directed to $10.10.3.2$ and Ack/nAck packets having $10.10.2.0$ IP will be directed to $10.10.2.1$. For all other nodes same logic apply for them. See $Fig. 6$ [See Appendix in Section \ref{appendix}]\\
In the route table there are some $.0$ s in the IPs (e.g. $10.10.3.0$), it means in the place of $0s$, any value is accepted. More generally, in the design of servers, $0.0.0.0$ corresponds "all $IPv4$ addresses on the machine. 
\subsection{Main Design}
We have decided to use $python3$ to write scripts and create classes for each Source, Broker and Destination nodes. Sockets are opening with port numbers and IPs are assigned in constructors for all classes in our design. In source class we have created TCP connection and read the given large file as chunks which are $996$ $(MAX\_PACKET\_SIZE - 4)$ bytes (MAX\_PACKET\_SIZE depends on designer of applying topology) bytes for each, since we are adding headers to packets in broker node (default size $1000$ bytes). Since we are going to examine the time difference again (similar to part $1$), we got the time from \href{https://developers.google.com/time/}{NTP Server of Google} when first packet sent from source node and last packet received at destination to synchronization of the nodes. In broker, we have created $2$ classes, one for receiving data from source node and one for sending data to destination node. While receiving from source node only TCP rules apply (see part $1$ for detailed explanation) and as soon as packet received in receiver class, it pass that packet to sender class.We have realize that last packet that is sending with TCP is empty (b'') on broker node. Therefore, we used flags (basic integer variables to decide different situations -to be explained in corresponding sections-). When we read last packet from source node (which is empty(b'') because of TCP), we set flag variable to $2$ which we use as condition code to say it's the last packet that is going to be received and last packet it is going to be send. We need to apply multihoming which connects broker to destination with more than one routers. This provide us to increase performance. After doing so, broker decides that one packet is forwarding to destination from router $1$, other from router $2$. While $1$ packet is forwarding to router $1$, other needs to be forwarded to router $2$, to achieve this, we used threads in broker node. We need to create packets and parse packets in broker, while parsing we are parsing packet and calculate the necessary info from them. While making packet, we are creating packet and including necessary info in it. To validate the receiving packet, we make checksum comparison with checksum value in the packet and re-calculated rsum value from data in the packet. We have added cumulative ACKs for all window-sized packets instead of taking ACK for each of packet inorder to save time. When we send a packet in broker we have started a timer to determine timeouts (value is given $0.2$). To achieve the problem which if there are still unacked packets greater than window size or, packet is the last packet that we need to send while there are still unacked packets; we are waiting for correct acks without time-out. If there is no time-out, we set our variables to use them again, but if the packet is the last one, we send it again. When there is time-out, without making any modification, the reliability is breaking down. Therefore, we have applied reliable data transfer method, pipe-lining, in specific Go-Back-N. (Above paragraph is kind of description of Go-Back-N). In destination node's script, although our implementation is based on Go-Back- N, we are receiving packets unsorted order in some cases since we have applied multihoming in our network (receiving both from router $1$ and router $2$). So, just to be sure in order to sort packets and merge them correctly, first we are saving all packets in a list which is holding data then sort them. After receiving a packet, again we parse the packet, get the checksum value and sequence number in packet and calculate rsum value then compare them. If they match, we are sending ACK for next sequence number. If not, we are sending nAck for that sequence number. In Ack and nAck packets, we have checksum, flag, sequence number and empty data, since we are using them only for validation. When the last packet arrives, destination class get time from same NTP Server and print arrival time. If there is no traffic in between $60$ seconds, our destination timed-out. After receiving last packet correctly, we are writing our data, in the list that we have store them unsorted order, in sorting order. While sorting, python3 has sort() function which is called Tim Sort also, takes $O(n log n)$(This is one of the advantage that make us to decide to use python3 to write scripts). After making successful sorting we write our received packets to file $(output2.txt)$ respectively.